# 构造函数总结
构造函数包括： 默认构造函数， 拷贝构造函数，移动构造函数
默认构造函数(primer p235 p257 p551 p689)

## 默认构造函数 
定义：无需任何实参的成员函数
特点： 
1. 无需任何实参，没有返回值 
2. 如果我们没有定义任何构造函数，编译器会为我们隐式地定义一个合成默认构造函数 （合成默认构造函数初始化类成员的规则： 首先使用类内初始值，如没有则使用默认初始化）
必须给自己设计的普通类定义默认构造函数，原因有三点：
1. 一旦定义其他构造函数，则会导致没有合成的默认构造函数。
2. 合成的默认构造函数如果采用了默认初始化，则有可能产生未定义的行为。
3. 编译器无法未某些类合成默认构造函数，比如类中包含其他类型的成员，且这个成员的类型没有默认构造函数 （p449还有其他的情况导致百年一起无法合成默认构造函数）

### 默认构造函数在什么时候执行：
当对象被默认初始化或者值初始化的时候自动执行默认构造函数
1. 默认初始化： 
   1. 块作用域内不使用任何初始值定义一个非静态变量，
   2. 当一个类本身含有类类型的成员并且使用合成的默认构造
   3. 当类类型成员没有在构造函数初始值列表中显示地初始化时
2. 值初始化：
   1. 数组初始化过程中，提供的初始值数量少于数组的大小
   2. 不使用初始值定义一个局部静态变量时
   3. 通过书写形如T()的表达式显示地请求值初始化时，其中T 是类型名。

## 构造函数初始值列表
const 和引用类型的数据成员必须在初始值列表中初始化
成员的初始化顺序为定义的顺序

## 默认实参和构造函数
```c++
class Sales_data
{    
public:
    //定义默认构造函数，令其与只接受一个string 实参的构造函数功能相同
    Sales_data(std::string s = ""):bookNo(s){}
};
```

## 委托构造函数 c++11

```c++
class Sales_data
{    
public:
    
    Sales_data(std::string s ,unsigned cnt, double price):bookNo(s), unites_sold(cnt), revenue(cnt*price){

    }
    ////定义默认构造函数，委托给第一个构造函数，受委托的构造函数的初始值列表和函数体依次执行
    Sales_data():Sales_data("", 0,0) {}
};
```


## 含有一个参数的构造函数的默认类型转换
只允许一步类类型转换
加上explicit 关键字阻止隐式的类类型转换

## 为什么会有这种类型转换

# 问题
`string str = "12345";` 是先把右边的`char*`隐式转换为`string`再赋值吗？
答： 是的，这是拷贝初始化。等号右边先调用默认构造函数隐式转化构造`string`对象，再调用拷贝构造函数将转化得到的`string`对象拷贝到等号左侧对象中。

## 派生类的构造函数
派生类会在值初始化列表中调用基类的构造函数来初始化基类的成员
```c++
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc) : Quote(book,p),min_qty(qty), discount(disc) {}
```

## 继承的构造函数 (primer p557)
一个类只继承其直接基类的构造函数。类不能继承默认，拷贝和移动构造函数。 如果派生类没有定义这些构造函数，则编译器会为派生类合成。
特点：
- using声明不会改变构造函数的访问级别和explicit constexpr属性，取决于基类的访问级别和属性
- 基类的默认实参不会被继承，派生类会获得多个继承的构造函数，每个分别省略一个默认实参
- 派生类如果定义了与基类具有相同参数列表的构造函数，则这部分构造函数不会被继承， 除此之外默认，拷贝和移动构造函数不会被继承。
  
```c++
class Bulk_quote : public Disc_quote
{
public:
    using Disc_quote::Disc_quote;
    double net_price(std::size_t) const;
}

//继承的构造函数等价于
Bulk_quote(const std::string & book, double price, std::size_t qty, double disc): Disc_quote(book,price,qty,disc){}
```

